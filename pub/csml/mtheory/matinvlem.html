<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
		 <!-- Un-minified script so that can play a bit -->
<link rel="stylesheet" href="/libs/katex/katex.min.css"></link>
 		
         <!-- Syntax highlighting via Prism, note: restricted langs -->
<link rel="stylesheet" href="/libs/highlight/github.min.css">
 	
		
			<link rel="stylesheet" href="/css/main.css">
	        <link rel="icon" href="/assets/infra/favicon.png">
		
		 <title>Matrix inversion lemmas</title>	
	</head>
    <body>
		
        <header>
            <div class="blog-name"><a href="/">Thibaut Lienart</a></div>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                    <li><a href="/pub/csml.html">CS/ML notes</a></li>
                    <li><a href="/pub/julia.html">Julia notes</a></li>
                    <!-- <li><a href="/pub/misc.html">Misc.</a></li> -->
                </ul>
                <img src="/assets/infra/hamburger.svg" id="menu-icon">
            </nav>
        </header>
		

<!-- Content appended here -->

<div class="jd-content">
<h1 id="matrix_inversion_lemmas"><a href="/pub/csml/mtheory/matinvlem.html#matrix_inversion_lemmas">Matrix inversion lemmas</a></h1>
<p>The <em>Woodbury formula</em> is maybe one of the most ubiquitous trick in basic linear algebra: it starts with the explicit formula for the inverse of a block 2x2 matrix and results in identities that can be used in kernel theory, the Kalman filter, to combine multivariate normals etc.</p>
<p>In these notes I present a simple development leading to the Woodbury formula, and the special case of the Sherman-Morrison formula with some code to show those at work.</p>
<h2 id="partitioned_matrix_inversion"><a href="/pub/csml/mtheory/matinvlem.html#partitioned_matrix_inversion">Partitioned matrix inversion</a></h2>
<p>Consider an invertible matrix \(M\) made of blocks \(A\), \(B\), \(C\) and \(D\) with</p>
\[
M \quad\!\! =\quad\!\! \begin{pmatrix} A & B \\ C & D \end{pmatrix}
\]
<p>where both \(A\) and \(D\) are assumed to be square and invertible. The aim is to express the inverse of \(M\) in terms of the blocks \(A\), \(B\), \(C\) and \(D\) and the inverse of \(A\) and \(D\). We can write the inverse of \(M\) using an identical structure:</p>
\[
M^{-1} \quad\!\! =\quad\!\! \begin{pmatrix} W & X \\ Y& Z \end{pmatrix},
\]
<p>for some \(W\), \(X\), \(Y\) and \(Z\) to be determined. Using \(MM^{-1} = \mathbf I\) since \(M\) is assumed to be invertible, we get the following system of equations:</p>
\[
\begin{cases}
    AW + BY &=\quad\!\! \mathbf I \\
    AX + BZ &=\quad\!\! \mathbf 0 \\
    CW + DY &=\quad\!\! \mathbf 0 \\
    CX + DZ &=\quad\!\! \mathbf I
\end{cases}
\]<pre><code class="language-julia">AW + BY &=\esp \mathbf I \\
AX + BZ &=\esp \mathbf 0 \\
CW + DY &=\esp \mathbf 0 \\
CX + DZ &=\esp \mathbf I</code></pre>\end&#123;cases&#125; &#36;</p>
<p>Left multiplying the first two equations by \(A^{-1}\) and the last two by \(D^{-1}\) and re-arranging a little gives <a id="step-a"></a>\[
\begin{cases}
    (\mathbf I - A^{-1} B D^{-1} C)W  &=\quad\!\! A^{-1}\\
    (\mathbf I - D^{-1} CA^{-1} B)Z   &=\quad\!\! D^{-1}\\
\end{cases}
\quad\text{and}\quad
\begin{cases}
    X &=\quad\!\! -A^{-1} B Z\\
    Y &=\quad\!\! -D^{-1} C W
\end{cases}
\]<pre><code class="language-julia">(\mathbf I - A\inv B D\inv C)W  &=\esp A\inv\\
(\mathbf I - D\inv CA\inv B)Z   &=\esp D\inv\\</code></pre>\end&#123;cases&#125; \quad\text&#123;and&#125;\quad \begin&#123;cases&#125;<pre><code class="language-julia">X &=\esp -A\inv B Z\\
Y &=\esp -D\inv C W</code></pre>\end&#123;cases&#125;\label&#123;step-A&#125; &#36;</p>
<p>The first two equations can be further simplified using that \((E F)^{-1} = F^{-1} E^{-1}\) for square invertible matrices \(E\) and \(F\):</p>
<a id="step-wz"></a>\[
\begin{cases}
    W &=\quad\!\! (A - BD^{-1} C)^{-1}\\
    Z &=\quad\!\! (D - CA^{-1} B)^{-1}
\end{cases}
\]<pre><code class="language-julia">W &=\esp (A - BD\inv C)\inv\\
Z &=\esp (D - CA\inv B)\inv</code></pre>\end&#123;cases&#125;\label&#123;step-WZ&#125; &#36;</p>
<p>We started with \(MM^{-1} = \mathbf I\) but we could have started with \(M^{-1} M=\mathbf I\) of course. This gives an equivalent result but the form obtained for \(Y\) and \(X\) is different:</p>
<a id="step-b"></a>\[
\begin{cases}
    Y &=\quad\!\! -ZCA^{-1}\\
    X &=\quad\!\! -WBD^{-1}
\end{cases}

\]<pre><code class="language-julia">Y &=\esp -ZCA\inv\\
X &=\esp -WBD\inv</code></pre>\end&#123;cases&#125; \label&#123;step-B&#125; &#36;</p>
<h3 id="basic_lemmas"><a href="/pub/csml/mtheory/matinvlem.html#basic_lemmas">Basic lemmas</a></h3>
<p>Equating the expressions in <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#step-a">4</a>)</span> and <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#step-b">6</a>)</span> for \(Y\) gives \(D^{-1} CW = ZCA^{-1}\) which, combined with <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#step-wz">5</a>)</span> gives the first lemma.</p>
<div class="colbox-blue">&#40;<strong>Lemma I</strong>&#41; let \(A\) and \(D\) be square, invertible matrices of size \(n_A\times n_A\) and \(n_D\times n_D\) and \(B\) and \(C\) be matrices of size \(n_A\times n_D\) and \(n_D\times n_A\), the following identity holds: <a id="lemma1"></a>\[
D^{-1} C (A-BD^{-1} C)^{-1} \quad\!\! =\quad\!\! (D - CA^{-1} B)^{-1} CA^{-1}.
\]</div>
<p>Equating the expressions in <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#step-a">4</a>)</span> and <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#step-b">6</a>)</span> for \(X\) gives \(WBD^{-1} = A^{-1} B Z \) which, combined with <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#step-wz">5</a>)</span> gives the second lemma.</p>
<div class="colbox-blue">&#40;<strong>Lemma II</strong>&#41; under the same assumptions as for Lemma I, the following identity holds: <a id="lemma2"></a>\[
(A - BD^{-1} C)^{-1} BD^{-1} \quad\!\! =\quad\!\! A^{-1} B (D - CA^{-1} B)^{-1}.
\]</div>
<h3 id="woodbury_formula"><a href="/pub/csml/mtheory/matinvlem.html#woodbury_formula">Woodbury formula</a></h3>
<p>One little bit of dark magic is required to get the Woodbury formula: observe that if we take the term \((A-BD^{-1} C)\) and right-multiply it by \(-A^{-1}\) we get</p>
\[ (A-BD^{-1} C)(-A^{-1}) \quad\!\! =\quad\!\! \textcolor{green}{BD^{-1}}\textcolor{blue}{CA^{-1}} - \mathbf I  \]
<p>and therefore \(BD^{-1} CA^{-1} = (\mathbf I + (A-BD^{-1} C)(-A^{-1})\). Now if we post-multiply <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#lemma2">8</a>)</span> by \(CA^{-1}\) and re-arrange the expression, we get the third lemma.</p>
<div class="colbox-blue">&#40;<strong>Lemma III</strong>&#41; under the same assumptions as for Lemma I, the following identity holds: <a id="lemma3"></a>\[
(A-BD^{-1} C)^{-1} \quad\!\! =\quad\!\! A^{-1} + A^{-1} B(D-CA^{-1} B)^{-1} CA^{-1}.
\]</div>
<p>of course the same gymnastics can be applied with the term \((D-CA^{-1} B)^{-1}\) to obtain a similar identity. To obtain the classical Woodbury formula though, we just need to reassign letters with \(E\leftarrow A\), \(F\leftarrow -B\), \(G\leftarrow D^{-1}\) and \(H\leftarrow C\). &#40;So Lemma III is already the Woodbury formula, the re-assignment only leads to a somewhat more visually pleasing form&#41;</p>
<div class="colbox-blue">&#40;<strong>Woodbury formula</strong>&#41; let \(E\), \(G\) be square invertible matrices of dimensions \(n_E \times n_E\) and \(n_G\times n_G\) respectively, let \(F\) and \(H\) be matrices of size \(n_E\times n_G\) and \(n_G\times n_E\) respectively, then the following identity holds: <a id="woodbury"></a>\[ (E+FGH)^{-1} \quad\!\! =\quad\!\! E^{-1} - E^{-1} F(G^{-1} + HE^{-1} F)^{-1} H E^{-1} \]</div>
<h3 id="sherman-morrison_formula"><a href="/pub/csml/mtheory/matinvlem.html#sherman-morrison_formula">Sherman-Morrison formula</a></h3>
<p>Consider again <span class="eqref">(<a href="/pub/csml/mtheory/matinvlem.html#woodbury">11</a>)</span> and let \(G=1\), \(F=u\) and \(H=v\) with \(u, v\in\mathbb R^{n_E}\) then the formula gives</p>
\[ (E+uv^T)^{-1} \quad\!\! =\quad\!\! E^{-1} -{E^{-1} u v^T E^{-1}\over 1 + v^T E^{-1} u}, \]
<p>a useful expression for the inverse of a matrix combined with a rank-1 perturbation. This is used for instance in the development of the famous BFGS flavour of the Quasi-Newton iterations &#40;see e.g. the <a href="https://en.wikipedia.org/wiki/Broyden&#37;E2&#37;80&#37;93Fletcher&#37;E2&#37;80&#37;93Goldfarb&#37;E2&#37;80&#37;93Shanno_algorithm">wikipedia article</a>&#41;.  </p>
<h2 id="a_bit_of_code"><a href="/pub/csml/mtheory/matinvlem.html#a_bit_of_code">A bit of code</a></h2>
<p>If you want to see these equations at work, here&#39;s a simple Julia script:</p>
<pre><code class="language-julia">using Test
# Woodbury formula
n_E, n_G = 13, 15;
E = randn(n_E, n_E);
F = randn(n_E, n_G);
G = randn(n_G, n_G);
H = randn(n_G, n_E);
iE, iG = inv(E), inv(G);
@test inv(E+F*G*H) ≈ iE - iE*F*inv(iG + H*iE*F)*H*iE

# Sherman-Morrison formula
n_E = 23;
E = randn(n_E, n_E);
u = randn(n_E);
v = randn(n_E);
iE = inv(E)
iEu = iE*u
@test inv(E + u*v') ≈ iE - (iEu*(v'*iE))/(1+dot(v, iEu))
</code></pre>
<p>&#40;Recall that invertible matrices are dense among square matrices so that using randomly generated matrices for \(E\) and \(G\) is unlikely to cause problems&#41;.</p>
<p>Interestingly <a href="https://github.com/timholy">Tim Holy</a> has written a simple  package for this called <a href="https://github.com/timholy/WoodburyMatrices.jl"><code>WoodburyMatrices.jl</code></a>.</p>
<pre><code class="language-julia">using WoodburyMatrices
W = Woodbury(E, F, G, H);
b = randn(n_E);
# using the package
s1 = W\b;
# hand-coding using the formula
iEb = iE*b;
s2  = iEb - iE*(F*((iG+H*iE*F)\(H*iEb)))
@test s1 ≈ s2
</code></pre>
<div class="page-foot">
		<div class="copyright">
				&copy; T. Lienart. Last modified: December 29, 2018. Website built with <a href="https://github.com/tlienart/JuDoc.jl">JuDoc.jl</a>.
		</div>
</div>

</div>
<!-- CONTENT ENDS HERE -->
        
                <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

        
        
                <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

        
    </body>
</html>
